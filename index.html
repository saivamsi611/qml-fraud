<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QML Fraud Detection</title>

    <link rel="icon" href="/favicon.ico" type="image/x-icon" />

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: black;
        overflow: hidden;
        color: white;
        font-family: Arial, sans-serif;
      }

      #bg-canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1;
      }

      #root {
        position: relative;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <!-- Background -->
    <canvas id="bg-canvas"></canvas>

    <!-- React Root -->
    <div id="root"></div>

    <!-- React Entry -->
    <script type="module" src="/src/main.jsx"></script>

    <!-- Three.js Background Script -->
    <script>
      const canvas = document.getElementById("bg-canvas");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;

      // Particles
      const particles = new THREE.BufferGeometry();
      const particleCount = 2000;
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 10;
      }

      particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.02,
      });

      const pointCloud = new THREE.Points(particles, material);
      scene.add(pointCloud);

      function animate() {
        requestAnimationFrame(animate);
        pointCloud.rotation.y += 0.0015;
        pointCloud.rotation.x += 0.0007;
        renderer.render(scene, camera);
      }

      animate();

      // Resize handling
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
